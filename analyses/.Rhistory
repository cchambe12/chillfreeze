dvr.inter = stan('stan/dvr_winter_2level_ncp.stan', data = datalist.chill,
iter = 2500, warmup=1500, control=list(max_treedepth = 12,adapt_delta = 0.99))
dvr.inter = stan('stan/dvr_winter_2level_ncp.stan', data = datalist.chill,
iter = 2500, warmup=1500, control=list(max_treedepth = 12,adapt_delta = 0.99))
check_all_diagnostics(dvr.inter)
#library(bayesplot)
y <- as.vector(chill.stan$dvr)
yrep <- extract(dvr.inter)
yrep <- yrep$yhat
ppc <- ppc_stat(y, yrep)
ppc.max <- ppc_stat(y, yrep, stat = "max")
ppc.min <- ppc_stat(y, yrep, stat = "min")
ppc.sd <- ppc_stat(y, yrep, stat = "sd")
#library(egg)
quartz()
grid.arrange(ppc, ppc.sd, ppc.max, ppc.min, ncol=2, nrow=2)
dvr.inter.pois = stan('stan/dvr_winter_2level_pois.stan', data = datalist.chill,
iter = 2500, warmup=1500, control=list(max_treedepth = 12,adapt_delta = 0.99)) ## 12 divergent transitions
dvr.inter.pois = stan('stan/dvr_winter_2level_pois.stan', data = datalist.chill,
iter = 2500, warmup=1500, control=list(max_treedepth = 12,adapt_delta = 0.99)) ## 12 divergent transitions
dvr.inter.pois = stan('stan/dvr_winter_2level_pois.stan', data = datalist.chill,
iter = 2500, warmup=1500, control=list(max_treedepth = 12,adapt_delta = 0.99)) ## 12 divergent transitions
dvr.inter.pois = stan('stan/dvr_winter_2level_pois.stan', data = datalist.chill,
iter = 2500, warmup=1500, control=list(max_treedepth = 12,adapt_delta = 0.99)) ## 12 divergent transitions
dvr.inter.pois = stan('stan/dvr_winter_2level_pois.stan', data = datalist.chill,
iter = 2500, warmup=1500, control=list(max_treedepth = 12,adapt_delta = 0.99)) ## 12 divergent transitions
dvr.inter.pois = stan('stan/dvr_winter_2level_pois.stan', data = datalist.chill,
iter = 2500, warmup=1500, control=list(max_treedepth = 12,adapt_delta = 0.99)) ## 12 divergent transitions
dvr.inter.pois = stan('stan/dvr_winter_2level_pois.stan', data = datalist.chill,
iter = 2500, warmup=1500, control=list(max_treedepth = 12,adapt_delta = 0.99)) ## 12 divergent transitions
datalist.chill.pois <- with(chill.stan,
list(y = as.integer(dvr),
tx = tx,
chill1 = chill1,
chill2 = chill2,
sp = as.numeric(as.factor(species)),
N = nrow(chill.stan),
n_sp = length(unique(chill.stan$species))
)
)
dvr.inter.pois = stan('stan/dvr_winter_2level_pois.stan', data = datalist.chill.pois,
iter = 2500, warmup=1500, control=list(max_treedepth = 12,adapt_delta = 0.99)) ## 12 divergent transitions
View(chill.stan)
dim(chill.stan$dvr)
dims(chill.stan$dvr)
dim(chill.stan)
View(datalist.chill.pois)
dvr.inter.ncp = stan('stan/dvr_winter_2level_ncp.stan', data = datalist.chill,
iter = 2500, warmup=1500, control=list(max_treedepth = 12,adapt_delta = 0.99)) ## 12 divergent transitions
check_all_diagnostics(dvr.inter.pois)
datalist.chill.pois <- with(chill.stan,
list(y = as.integer(dvr),
tx = tx,
chill1 = chill1,
chill2 = chill2,
sp = as.numeric(as.factor(species)),
N = nrow(chill.stan),
n_sp = length(unique(chill.stan$species))
)
)
dvr.inter.pois = stan('stan/dvr_winter_2level_pois.stan', data = datalist.chill.pois,
iter = 2500, warmup=1500, control=list(max_treedepth = 12,adapt_delta = 0.99)) ## 12 divergent transitions
dvr.inter.pois = stan('stan/dvr_winter_2level_pois.stan', data = datalist.chill.pois,
iter = 2500, warmup=1500, control=list(max_treedepth = 12,adapt_delta = 0.99)) ## 12 divergent transitions
check_all_diagnostics(dvr.inter.pois)
#library(bayesplot)
y <- as.vector(chill.stan$dvr)
yrep <- extract(dvr.inter)
yrep <- yrep$yhat
ppc <- ppc_stat(y, yrep)
ppc.max <- ppc_stat(y, yrep, stat = "max")
ppc.min <- ppc_stat(y, yrep, stat = "min")
ppc.sd <- ppc_stat(y, yrep, stat = "sd")
grid.arrange(ppc, ppc.sd, ppc.max, ppc.min, ncol=2, nrow=2)
#library(egg)
quartz()
grid.arrange(ppc, ppc.sd, ppc.max, ppc.min, ncol=2, nrow=2)
yrep <- extract(dvr.inter.pois)
yrep <- yrep$yhat
ppc <- ppc_stat(y, yrep)
ppc.max <- ppc_stat(y, yrep, stat = "max")
ppc.min <- ppc_stat(y, yrep, stat = "min")
ppc.sd <- ppc_stat(y, yrep, stat = "sd")
grid.arrange(ppc, ppc.sd, ppc.max, ppc.min, ncol=2, nrow=2)
rm(list=ls())
options(stringsAsFactors = FALSE)
# Load libraries
library(shinystan)
library(rstan)
library(rstanarm)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
# Set working directory
setwd("~/Documents/git/chillfreeze/analyses")
source('source/stan_utility.R')
chill.stan <- read.csv("output/clean_dvr_60dayoutput.csv", header=TRUE)
chill.stan <- chill.stan[!is.na(chill.stan$dvr),]
nospp <- c("NYSSYL", "FAGGRA") # species to exclude for now because not enough data
chill.stan <- chill.stan[!(chill.stan$species%in%nospp),]
chill.stan <- subset(chill.stan, select=c("dvr", "tx", "chill1", "chill2", "species"))
datalist.chill <- with(chill.stan,
list(y = dvr,
tx = tx,
chill1 = chill1,
chill2 = chill2,
sp = as.numeric(as.factor(species)),
N = nrow(chill.stan),
n_sp = length(unique(chill.stan$species))
)
)
dvr.inter.ncp = stan('stan/dvr_winter_2level_ncp.stan', data = datalist.chill,
iter = 2500, warmup=1500, control=list(max_treedepth = 12,adapt_delta = 0.99)) ## 12 divergent transitions
chill.stan <- read.csv("output/clean_dvr_60dayoutput.csv", header=TRUE)
chill.stan <- chill.stan[!is.na(chill.stan$dvr),]
chill.stan <- subset(chill.stan, select=c("dvr", "tx", "chill1", "chill2", "species"))
datalist.chill <- with(chill.stan,
list(y = dvr,
tx = tx,
chill1 = chill1,
chill2 = chill2,
sp = as.numeric(as.factor(species)),
N = nrow(chill.stan),
n_sp = length(unique(chill.stan$species))
)
)
dvr.inter.ncp = stan('stan/dvr_winter_2level_ncp.stan', data = datalist.chill,
iter = 2500, warmup=1500, control=list(max_treedepth = 12,adapt_delta = 0.99)) ## 12 divergent transitions
check_all_diagnostics(dvr.inter.ncp)
y <- as.vector(chill.stan$dvr)
yrep <- extract(dvr.inter.pois)
yrep <- yrep$yhat
ppc <- ppc_stat(y, yrep)
ppc.max <- ppc_stat(y, yrep, stat = "max")
ppc.min <- ppc_stat(y, yrep, stat = "min")
ppc.sd <- ppc_stat(y, yrep, stat = "sd")
#library(egg)
quartz()
grid.arrange(ppc, ppc.sd, ppc.max, ppc.min, ncol=2, nrow=2)
library(bayesplot)
y <- as.vector(chill.stan$dvr)
yrep <- extract(dvr.inter.pois)
yrep <- yrep$yhat
ppc <- ppc_stat(y, yrep)
ppc.max <- ppc_stat(y, yrep, stat = "max")
yrep <- extract(dvr.inter.ncp)
yrep <- yrep$yhat
ppc <- ppc_stat(y, yrep)
ppc.max <- ppc_stat(y, yrep, stat = "max")
ppc.min <- ppc_stat(y, yrep, stat = "min")
ppc.sd <- ppc_stat(y, yrep, stat = "sd")
grid.arrange(ppc, ppc.sd, ppc.max, ppc.min, ncol=2, nrow=2)
nsp = 10 # number of species
ntot = 16 # numbers of individuals per species.
#  with species  (note to self: This is not the best, better to draw from a distribution)
intermean <- 16 # mean for selecting intercept (duration of vegetative risk) across all species
intersd <- 4 # SD for selecting species intercepts
spint <- rnorm(nsp, intermean, intersd)  # different intercepts by species
# now start building ...
testdat <- vector()
# assumptions:
# (a) predictors are NOT centered
# (b) predictors are not correlated
# (c) 2-way interactions only
# and some important points ...
# (z) the below draws treatments from distribution in such a way that there is a lot more variation than we have
for(i in 1:nsp){ # loop over species. i = 1
tx = rnorm(ntot, 18, 1) # for centered: force = rnorm(ntot, 0, 2)
chill1 = rnorm(ntot, 12, 1)
chill2 = rnorm(ntot, 9, 2)
# set up effect sizes
txcoef = 3 # steeper slope for false spring treatment
chill1coef = -1 # less steep for forcing
chill2coef = -2
# SD for each treatment
txcoef.sd = 1
chill1coef.sd = 0.5
chill2coef.sd = 0.8
# set interaction effects. 3 two-way interactions
txchill1coef = -0.5
txchill2coef = -1
# SD for interaction effects. 3 two-way interactions
txchill1coef.sd = 0.2
txchill2coef.sd = 0.8
# build model matrix
mm <- model.matrix(~(tx+chill1+chill2)^2, data.frame(tx, chill1, chill2))
# coefficients need to match the order of the colums in the model matrix (mm)
# so here, that's intercept, chill, force, photo
coeff <- c(spint[i],
rnorm(1, txcoef, txcoef.sd),
rnorm(1, chill1coef, chill1coef.sd),
rnorm(1, chill2coef, chill2coef.sd),
rnorm(1, txchill1coef, txchill1coef.sd),
rnorm(1, txchill2coef, txchill2coef.sd)
)
dvr <- rnorm(n = ntot, mean = mm %*% coeff, sd = 0.1)
testdatx <- data.frame(dvr, sp = i,
tx, chill1, chill2)
testdat <- rbind(testdat, testdatx)
}
View(mm)
# build model matrix
mm <- model.matrix(~(tx+chill1+chill2+txchill1+txchill2), data.frame(tx, chill1, chill2))
# build model matrix
mm <- model.matrix(~(tx+chill1+chill2+tx:chill1+tx:chill2), data.frame(tx, chill1, chill2))
# coefficients need to match the order of the colums in the model matrix (mm)
# so here, that's intercept, chill, force, photo
coeff <- c(spint[i],
rnorm(1, txcoef, txcoef.sd),
rnorm(1, chill1coef, chill1coef.sd),
rnorm(1, chill2coef, chill2coef.sd),
rnorm(1, txchill1coef, txchill1coef.sd),
rnorm(1, txchill2coef, txchill2coef.sd)
)
dvr <- rnorm(n = ntot, mean = mm %*% coeff, sd = 0.1)
testdatx <- data.frame(dvr, sp = i,
tx, chill1, chill2)
testdat <- rbind(testdat, testdatx)
View(testdat)
nsp = 10 # number of species
ntot = 16 # numbers of individuals per species.
#  with species  (note to self: This is not the best, better to draw from a distribution)
intermean <- 16 # mean for selecting intercept (duration of vegetative risk) across all species
intersd <- 4 # SD for selecting species intercepts
spint <- rnorm(nsp, intermean, intersd)  # different intercepts by species
# now start building ...
testdat <- vector()
# assumptions:
# (a) predictors are NOT centered
# (b) predictors are not correlated
# (c) 2-way interactions only
# and some important points ...
# (z) the below draws treatments from distribution in such a way that there is a lot more variation than we have
for(i in 1:nsp){ # loop over species. i = 1
tx = rnorm(ntot, 18, 1) # for centered: force = rnorm(ntot, 0, 2)
chill1 = rnorm(ntot, 12, 1)
chill2 = rnorm(ntot, 9, 2)
# set up effect sizes
txcoef = 3 # steeper slope for false spring treatment
chill1coef = -1 # less steep for forcing
chill2coef = -2
# SD for each treatment
txcoef.sd = 1
chill1coef.sd = 0.5
chill2coef.sd = 0.8
# set interaction effects. 3 two-way interactions
txchill1coef = -0.5
txchill2coef = -1
# SD for interaction effects. 3 two-way interactions
txchill1coef.sd = 0.2
txchill2coef.sd = 0.8
# build model matrix
mm <- model.matrix(~(tx+chill1+chill2+tx:chill1+tx:chill2), data.frame(tx, chill1, chill2))
# coefficients need to match the order of the colums in the model matrix (mm)
# so here, that's intercept, chill, force, photo
coeff <- c(spint[i],
rnorm(1, txcoef, txcoef.sd),
rnorm(1, chill1coef, chill1coef.sd),
rnorm(1, chill2coef, chill2coef.sd),
rnorm(1, txchill1coef, txchill1coef.sd),
rnorm(1, txchill2coef, txchill2coef.sd)
)
dvr <- rnorm(n = ntot, mean = mm %*% coeff, sd = 0.1)
testdatx <- data.frame(dvr, sp = i,
tx, chill1, chill2)
testdat <- rbind(testdat, testdatx)
}
View(testdat)
View(mm)
for(i in 1:nsp){ # loop over species. i = 1
tx = rnorm(ntot, 1, 0.5) # for centered: force = rnorm(ntot, 0, 2)
chill1 = rnorm(ntot, 1, 0.5)
chill2 = rnorm(ntot, 1, 0.5)
# set up effect sizes
txcoef = 3 # steeper slope for false spring treatment
chill1coef = -1 # less steep for forcing
chill2coef = -2
# SD for each treatment
txcoef.sd = 1
chill1coef.sd = 0.5
chill2coef.sd = 0.8
# set interaction effects. 3 two-way interactions
txchill1coef = -0.5
txchill2coef = -1
# SD for interaction effects. 3 two-way interactions
txchill1coef.sd = 0.2
txchill2coef.sd = 0.8
# build model matrix
mm <- model.matrix(~(tx+chill1+chill2+tx:chill1+tx:chill2), data.frame(tx, chill1, chill2))
# coefficients need to match the order of the colums in the model matrix (mm)
# so here, that's intercept, chill, force, photo
coeff <- c(spint[i],
rnorm(1, txcoef, txcoef.sd),
rnorm(1, chill1coef, chill1coef.sd),
rnorm(1, chill2coef, chill2coef.sd),
rnorm(1, txchill1coef, txchill1coef.sd),
rnorm(1, txchill2coef, txchill2coef.sd)
)
dvr <- rnorm(n = ntot, mean = mm %*% coeff, sd = 0.1)
testdatx <- data.frame(dvr, sp = i,
tx, chill1, chill2)
testdat <- rbind(testdat, testdatx)
}
View(testdat)
nsp = 10 # number of species
ntot = 16 # numbers of individuals per species.
#  with species  (note to self: This is not the best, better to draw from a distribution)
intermean <- 16 # mean for selecting intercept (duration of vegetative risk) across all species
intersd <- 4 # SD for selecting species intercepts
spint <- rnorm(nsp, intermean, intersd)  # different intercepts by species
nsp = 10 # number of species
ntot = 48 # numbers of individuals per species.
#  with species  (note to self: This is not the best, better to draw from a distribution)
intermean <- 16 # mean for selecting intercept (duration of vegetative risk) across all species
intersd <- 4 # SD for selecting species intercepts
spint <- rnorm(nsp, intermean, intersd)  # different intercepts by species
# now start building ...
testdat <- vector()
for(i in 1:nsp){ # loop over species. i = 1
tx = rnorm(ntot, 1, 0.5) # for centered: force = rnorm(ntot, 0, 2)
chill1 = rnorm(ntot, 1, 0.5)
chill2 = rnorm(ntot, 1, 0.5)
# set up effect sizes
txcoef = 3 # steeper slope for false spring treatment
chill1coef = -1 # less steep for forcing
chill2coef = -2
# SD for each treatment
txcoef.sd = 1
chill1coef.sd = 0.5
chill2coef.sd = 0.8
# set interaction effects. 3 two-way interactions
txchill1coef = -0.5
txchill2coef = -1
# SD for interaction effects. 3 two-way interactions
txchill1coef.sd = 0.2
txchill2coef.sd = 0.8
# build model matrix
mm <- model.matrix(~(tx+chill1+chill2+tx:chill1+tx:chill2), data.frame(tx, chill1, chill2))
# coefficients need to match the order of the colums in the model matrix (mm)
# so here, that's intercept, chill, force, photo
coeff <- c(spint[i],
rnorm(1, txcoef, txcoef.sd),
rnorm(1, chill1coef, chill1coef.sd),
rnorm(1, chill2coef, chill2coef.sd),
rnorm(1, txchill1coef, txchill1coef.sd),
rnorm(1, txchill2coef, txchill2coef.sd)
)
dvr <- rnorm(n = ntot, mean = mm %*% coeff, sd = 0.1)
testdatx <- data.frame(dvr, sp = i,
tx, chill1, chill2)
testdat <- rbind(testdat, testdatx)
}
View(testdat)
write.csv(testdat, file="~/Documents/git/chillfreeze/analyses/output/fakedata.csv", row.names = FALSE)
testdat <- read.csv("output/fakedata.csv", header=TRUE)
datalist.chill <- with(testdat,
list(y = dvr,
tx = tx,
chill1 = chill1,
chill2 = chill2,
sp = as.numeric(as.factor(species)),
N = nrow(chill.stan),
n_sp = length(unique(chill.stan$species))
)
)
View(testdat)
nsp = 10 # number of species
ntot = 48 # numbers of individuals per species.
#  with species  (note to self: This is not the best, better to draw from a distribution)
intermean <- 16 # mean for selecting intercept (duration of vegetative risk) across all species
intersd <- 4 # SD for selecting species intercepts
spint <- rnorm(nsp, intermean, intersd)  # different intercepts by species
# now start building ...
testdat <- vector()
# assumptions:
# (a) predictors are NOT centered
# (b) predictors are not correlated
# (c) 2-way interactions only
# and some important points ...
# (z) the below draws treatments from distribution in such a way that there is a lot more variation than we have
for(i in 1:nsp){ # loop over species. i = 1
tx = rnorm(ntot, 1, 0.5) # for centered: force = rnorm(ntot, 0, 2)
chill1 = rnorm(ntot, 1, 0.5)
chill2 = rnorm(ntot, 1, 0.5)
# set up effect sizes
txcoef = 3 # steeper slope for false spring treatment
chill1coef = -1 # less steep for forcing
chill2coef = -2
# SD for each treatment
txcoef.sd = 1
chill1coef.sd = 0.5
chill2coef.sd = 0.8
# set interaction effects. 3 two-way interactions
txchill1coef = -0.5
txchill2coef = -1
# SD for interaction effects. 3 two-way interactions
txchill1coef.sd = 0.2
txchill2coef.sd = 0.8
# build model matrix
mm <- model.matrix(~(tx+chill1+chill2+tx:chill1+tx:chill2), data.frame(tx, chill1, chill2))
# coefficients need to match the order of the colums in the model matrix (mm)
# so here, that's intercept, chill, force, photo
coeff <- c(spint[i],
rnorm(1, txcoef, txcoef.sd),
rnorm(1, chill1coef, chill1coef.sd),
rnorm(1, chill2coef, chill2coef.sd),
rnorm(1, txchill1coef, txchill1coef.sd),
rnorm(1, txchill2coef, txchill2coef.sd)
)
dvr <- rnorm(n = ntot, mean = mm %*% coeff, sd = 0.1)
testdatx <- data.frame(dvr, species = i,
tx, chill1, chill2)
testdat <- rbind(testdat, testdatx)
}
write.csv(testdat, file="~/Documents/git/chillfreeze/analyses/output/fakedata.csv", row.names = FALSE)
rm(list=ls())
options(stringsAsFactors = FALSE)
# Load libraries
library(bayesplot) ## for plotting
library(egg) ## for plotting
library(shinystan)
library(rstan)
library(rstanarm)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
# Set working directory
setwd("~/Documents/git/chillfreeze/analyses")
source('source/stan_utility.R')
testdat <- read.csv("output/fakedata.csv", header=TRUE)
datalist.chill <- with(testdat,
list(y = dvr,
tx = tx,
chill1 = chill1,
chill2 = chill2,
sp = as.numeric(as.factor(species)),
N = nrow(chill.stan),
n_sp = length(unique(chill.stan$species))
)
)
datalist.chill <- with(testdat,
list(y = dvr,
tx = tx,
chill1 = chill1,
chill2 = chill2,
sp = as.numeric(as.factor(species)),
N = nrow(testdat),
n_sp = length(unique(testdat$species))
)
)
dvr.inter.ncp = stan('stan/dvr_winter_2level_ncp.stan', data = datalist.chill,
iter = 2500, warmup=1500, control=list(max_treedepth = 12,adapt_delta = 0.99)) ## 2 divergent transitions
dvr.inter.ncp
check_all_diagnostics(dvr.inter.ncp)
y <- as.vector(chill.stan$dvr)
yrep <- extract(dvr.inter.ncp)
yrep <- yrep$yhat
ppc <- ppc_stat(y, yrep)
ppc.max <- ppc_stat(y, yrep, stat = "max")
ppc.min <- ppc_stat(y, yrep, stat = "min")
y <- as.vector(testdat$dvr)
yrep <- extract(dvr.inter.ncp)
yrep <- yrep$yhat
ppc <- ppc_stat(y, yrep)
ppc.max <- ppc_stat(y, yrep, stat = "max")
ppc.min <- ppc_stat(y, yrep, stat = "min")
ppc.sd <- ppc_stat(y, yrep, stat = "sd")
#
quartz()
grid.arrange(ppc, ppc.sd, ppc.max, ppc.min, ncol=2, nrow=2)
View(testdat)
dvr.inter = stan('stan/dvr_winter_2level.stan', data = datalist.chill,
iter = 2500, warmup=1500, control=list(max_treedepth = 12,adapt_delta = 0.99)) ### 32 divergent transitions
check_all_diagnostics(dvr.inter)
y <- as.vector(chill.stan$dvr)
y <- as.vector(testdat$dvr)
yrep <- extract(dvr.inter)
yrep <- yrep$yhat
ppc <- ppc_stat(y, yrep)
ppc.max <- ppc_stat(y, yrep, stat = "max")
ppc.min <- ppc_stat(y, yrep, stat = "min")
ppc.sd <- ppc_stat(y, yrep, stat = "sd")
grid.arrange(ppc, ppc.sd, ppc.max, ppc.min, ncol=2, nrow=2)
#
quartz()
grid.arrange(ppc, ppc.sd, ppc.max, ppc.min, ncol=2, nrow=2)
dvr.inter
dvr.inter = stan('stan/dvr_winter_2level.stan', data = datalist.chill,
iter = 2500, warmup=1500, control=list(max_treedepth = 12,adapt_delta = 0.99)) ### 32 divergent transitions
dvr.inter
dvr.inter.cauchy = stan('stan/dvr_winter_2level_cauchy.stan', data = datalist.chill,
iter = 2500, warmup=1500, control=list(max_treedepth = 12,adapt_delta = 0.99)) ### 32 divergent transitions
dvr.inter.cauchy
dvr.inter.normal = stan('stan/dvr_winter_2level.stan', data = datalist.chill,
iter = 2500, warmup=1500, control=list(max_treedepth = 12,adapt_delta = 0.99)) ### 32 divergent transitions
loo(dvr.inter.normal, dvr.inter.cauchy)
library(loo)
# Extract pointwise log-likelihood and compute LOO
log_lik_1 <- extract_log_lik(dvr.inter.normal, merge_chains = FALSE)
# Extract pointwise log-likelihood and compute LOO
log_lik_1 <- extract(dvr.inter.normal, merge_chains = FALSE)
# Extract pointwise log-likelihood and compute LOO
log_lik_1 <- extract(dvr.inter.normal)
# as of loo v2.0.0 we can optionally provide relative effective sample sizes
# when calling loo, which allows for better estimates of the PSIS effective
# sample sizes and Monte Carlo error
r_eff <- relative_eff(exp(log_lik_1))
loo1 <- loo(dvr.inter.normal)
dvr.inter.normal = stan('stan/dvr_winter_2level.stan', data = datalist.chill,
iter = 2500, warmup=1500, control=list(max_treedepth = 12,adapt_delta = 0.99)) ### 32 divergent transitions
dvr.inter.normal = stan('stan/dvr_winter_2level.stan', data = datalist.chill,
iter = 2500, warmup=1500, control=list(max_treedepth = 12,adapt_delta = 0.99)) ### 32 divergent transitions
dvr.inter.normal = stan('stan/dvr_winter_2level.stan', data = datalist.chill,
iter = 2500, warmup=1500, control=list(max_treedepth = 12,adapt_delta = 0.99)) ### 32 divergent transitions
